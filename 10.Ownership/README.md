# Ownership
## control memory tool
rust all data(value) have owner  
is only one value owner  
아 영어로 못해먹겠다..  
러스트는 소유권이라는 막강한 기능으로 메모리를 관리한다.  
이것의 장점이 무엇이냐면

1. C/C++에서는 포인터는 메모리를 강역하게 다룰 수 있지만 메모리를 수동으로 관리해야 해서 까먹으면 메모리 누수 중복해서 해제하면 이중해제로 오류, 저기서 해제 했는데 다른곳에서 그곳을 쓰려고 하는 상황이 발생하면 프로그램 터지면서 segmentation fault오류 띄움 같은 문제를 가지고 있다.
1. Java같은 언어들은 gc가 메모리를 관리해줘서 사용자가 신경 쓸 필요는 없지만 gc가 메모리를 잡아먹다보니 느리면서 메모리도 추가로 필요하게 된다.

위와같은 문제를 해결해준다.

## how to use ownership
소유권은 변수를 만들면 자동으로 생긴다.  
즉 어떠한 데이터를 만들고 그 데이터를 변수에 할당하면 해당 데이터의 소유권은 할당 받은 변수만 가지고 있다고 보면 된다.  
쉽게 생각하면 당신이 월급 통장을 만들어서 월급을 받으면 그 통장의 소유권은 당신이 가지고 있지 않은가..?  
```rust
/// num이 1이란 정보의 소유자가 된다.
let num = 1;
```
여기서 1이란 정보는 정확히는 해당 메모리 영역의 소유자라는 뜻으로 num이 1이란 정보를 가지고 있다 해서 새로운 변수i가 1을 못가진다는 것이 아니라 새로운 저장 영역에 1을 저장하는 것이 가능하다.  

## ownership example
자 소유권을 통해 메모리 영역을 각 변수가 가지는것은 알겠는데 그럼 메모리 관리가 어떻게 되냐는 의문이 있을 것이다.  
앞의 이야기만 보면 메모리 영역 할당만 하고(c언어로 치면 malloc) 해제(c언어 free)를 안하고 있다. 그런대 메모리가 관리가 된다고?  
된다! 어떻게 하냐면 모든 변수는 생명 주기가 있어서 해당 생명주기가 끝나면 자신이 가지고 있던 메모리 영역을 해제하여 os에게 여기 써도 된다고 전달하기 때문에 이 생명 주기 컨트롤을 통해 메모리를 관리한다.  
그럼 생명주기를 알아야 하니gc같은 것이 필요한 것이 아니냐 생각할 수 있는데 Java는 메모리의 사용여부를 gc가 관찰하다가 오랫동안 안쓰고 있으면 해당 영역을 비우는 것이지만 rust는 컴파일 단계부터 생명주기가 정해져 있어 gc같이 누군가 관찰 할 필요가 없다.  
그럼 rust의 생명주기는 어떻게 결정 되는가?
```rust
fn main(){
	let a = 1;//여기서 탄생
	...
}//여기서 소멸(해제)
```
rust의 생명 주기는 변수가 선언된 곳에서 메모리 할당을 받고 해당 변수가 있건 중괄호가 끝나는 곳에서 사라진다 보면 된다.  
자 그럼 아래 코드를 보자
```rust
fn main(){
	let qwer = String::from("qwerty");
	let qwerasdfzxcv = asdf(qwer);
}
fn asdf(s:String)->String{
	let zxcv = String::from("qwerasdfzxcv");
	return zxcv;
}
```
여기 asdf함수에는 2개의 변수가 있다. 첫번째로 안에 선언된 zxcv, 두번째로 매개변수로 받은 s가 있다.  
이 두 변수는 return zxcv;이후 중괄호가 닫히면서 메모리가 해제되어 더이상 쓸 수 없다. 여기서 중요한 점은 s는 매개변수로 asdf이 호출이 되었을 때의 qwer인데 앞에서 정보는 소유권을 할당 받은 변수만 가지고 있다고 했다. 즉 여기서 두가지로 생각 할 수 있는데

1. s와 qwer둘다 소유권을 가지고 있다.
1. s가 qwer의 소유권을 강탈해 갔다.

인데 1번과 같이 소유권을 이곳저곳에서 가지면 다른 애가 해제해버리면 원래 가지고 있던 애가 해제 되었는지 아닌지를 컴파일 단계에서 어떻게 알 수 있을까..?  
그래서 1번 방식이 아닌 2번 방식으로 한다. 그러므로 qwer은 소유권을 넘겨주면서 더이상 소유 하고 있는 메모리가 없으므로 그 이후 새롭게 할당하지 않고 그대로 사용하려 한다면 컴파일 단계에서 이 아이는 가지고 있는게 없는데? 이러면서 에러 띄워버린다.  
이것을 통해 이중해제나 nullpointer err나 **같은 segmentation fault을 방지 할 수 있다.  
이와 비슷하게 zxcv도 중괄호가 끝나면 해제되어야 하지만 return을 통해 qwerasdfzxcv에게 소유권을 넘기고 사라지므로 데이터"qwerasdfzxcv"는 qwerasdfzxcv에게서 살아 있게 된다.

## borrow
그럼 qwer을 살린 상태에서 사용 하고싶으면 어떻게 해야 할까? 당장 먼저 생각나는 방법은 shallow copy, deep copy를 응용해서 해결 하는 방법이 있을 것이다.
```rust
	let qwer = String::from("qwerty");
	let qwer_copy = qwer.copy();
	let qwerasdfzxcv = asdf(qwer_copy);
```
되기야 하겠지만 할때마다 복사를 하면 뭔가 몬가 하지 않은가? 그래서 이런 상황을 위해 있는 것이 빌림(borrow)기능이다. &! 그냥 C++의 &(참조연산자)와 비슷하다 보면 된다. 더이상 설명하기 귀찮다ㅎㅎ.. 예제를 보자
```rust
	let qwer = String::from("qwerty");
	let qwerasdfzxcv = asdf(&qwer);
```
물론 매개변수도 s:&String로 변경되긴 해야 하지만 이를 통해서 소유권을 잠시 빌려주고 생명주기가 끝나면 해제 하는 것이 아니라 소유권을 돌려주어 메모리를 유지 할 수 있는 상태로 만든다. 즉 여기 참조만 하고 건들지 마시오 하는 것이다. 물론 건들지 마시오니 변경이 안될거 같아 보이지만 &mut를 사용하면 변경도 되긴 한다. 마치 C의 포인터를 사용하는 것 처럼
```rust
fn main(){
	let mut qwerty = String::from("qwer");
	let mut a = 0;
	println!("{} {}",qwerty, a);
	ty(&mut qwerty, &mut a);
	println!("{} {}",qwerty, a);
}
fn ty(s:&mut String, &mut a:i32){
	s.push_str("ty");
	*a = 1;
}
```

	qwer 0
	qwerty 1

이런식으로 변경이 가능하다. 여기서 문자열은 그냥 쓰는데 정수는 뭔가 붙어있다!  
이는 정수는 스택영역에 저장되는 아이라 C언어 포인터 같이 어디에 있다를 알려주는 연산자가 붙는다.

## 끝!
끝 더이상 설명보단 써보면서 익숙해지는것 말고 답 없다 C/C++포인터가 그러하지 않은가 맨날 오류 보고 아 소유권 *** 하면서 익숙해저라 근데 이게 C/C++포인터보다 좋은게 포인터는 맨날 segmentation fault로 퉁치면서 어디 오류 난건지 안알려주던데 이건 "선셍님 이러이러한 변수가 소유권을 두고 싸우고 있습니다 가서 해결좀 보세요"하고 알려주니 얼마나 친절한가

이***같은 C/C++... 그래도 사랑한다!ㅎㅎ...